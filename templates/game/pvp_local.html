{% extends "base.html" %}

{% block title %}Local PvP - Super Tic-Tac-Toe{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/developer-theme.css') }}?v=16">
<style>
/* Override matrix rain colors to green */
.binary-char {
    color: rgba(34, 197, 94, 0.4) !important;
    text-shadow: 0 0 5px rgba(34, 197, 94, 0.3) !important;
}

@keyframes binaryFall {
    0% {
        transform: translateY(0);
        opacity: 0;
        color: rgba(34, 197, 94, 0.6) !important;
        text-shadow: 0 0 8px rgba(34, 197, 94, 0.4) !important;
    }
    5% {
        opacity: 1;
        color: rgba(34, 197, 94, 0.5) !important;
        text-shadow: 0 0 6px rgba(34, 197, 94, 0.3) !important;
    }
    50% {
        opacity: 0.8;
        color: rgba(34, 197, 94, 0.4) !important;
        text-shadow: 0 0 4px rgba(34, 197, 94, 0.2) !important;
    }
    85% {
        opacity: 0.6;
        color: rgba(34, 197, 94, 0.3) !important;
        text-shadow: 0 0 2px rgba(34, 197, 94, 0.1) !important;
    }
    100% {
        transform: translateY(100vh);
        opacity: 0;
        color: rgba(34, 197, 94, 0.1) !important;
        text-shadow: none !important;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="dev-container">
    <!-- Game Header -->
    <div class="dev-game-header">
        <h1 class="dev-game-title">
            > super_tic_tac_toe --mode=local_pvp
        </h1>

    </div>

    <!-- Game Status -->
    <div id="status" class="dev-game-status"></div>

    <!-- Game Board Container -->
    <div class="dev-game-container">
        <div id="board" class="dev-game-board"></div>
    </div>
    
    <!-- Control Buttons -->
    <div class="dev-game-controls" style="margin-top: 2rem;">
        <button id="reset-btn" class="dev-btn" style="background: var(--dev-white); color: var(--dev-dark); border: 1px solid var(--dev-border); font-family: var(--font-mono); font-weight: 500;">
            <i class="fas fa-refresh"></i>
            New Game
        </button>
        <a href="{{ url_for('main.dashboard') }}" class="dev-btn dev-btn-ghost">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
        </a>
    </div>
</div>

<!-- Matrix Rain Background -->
<div class="binary-bg" id="binary-background" style="z-index: -999; pointer-events: none; position: fixed;"></div>

<script>
// Game state variables
const gameId = {{ game_id }};
const boardContainer = document.getElementById("board");
const statusDisplay = document.getElementById("status");
let currentBoard = null;
let gameOver = false;
let currentPlayer = 1; // 1 for X, -1 for O
let legalMoves = [];
let accountOwnerIsPlayer1 = true;

function renderBoard(board, smallStatus) {
  boardContainer.innerHTML = "";

  for (let bigRow = 0; bigRow < 3; bigRow++) {
    for (let bigCol = 0; bigCol < 3; bigCol++) {
      const bigIndex = bigRow * 3 + bigCol;
      const smallBoard = document.createElement("div");
      smallBoard.className = "dev-small-board";
      smallBoard.id = `small-board-${bigIndex}`;
      
      // Check if this small board is won
      const smallWinner = smallStatus[bigRow][bigCol];
      if (smallWinner === 1) {
        console.log(`ðŸ”µ PLAYER 1 captured board [${bigRow}][${bigCol}]!`);
        smallBoard.classList.add('won-x');
      } else if (smallWinner === -1) {
        console.log(`ðŸ”´ PLAYER 2 captured board [${bigRow}][${bigCol}]!`);
        smallBoard.classList.add('won-o');
      }
      
      // Highlight current board
      if (currentBoard && currentBoard[0] === bigRow && currentBoard[1] === bigCol) {
        smallBoard.classList.add('active');
      }

      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          const r = bigRow * 3 + i;
          const c = bigCol * 3 + j;
          const val = board[r][c];
          const cell = document.createElement("div");
          const isLegal = legalMoves.some(([lr, lc]) => lr === r && lc === c);

          cell.className = "dev-cell";
          cell.dataset.row = r;
          cell.dataset.col = c;
          
          if (val === 1) {
            cell.textContent = "1";  // Using 1 instead of X for binary theme
            cell.classList.add('x', 'filled');
          } else if (val === -1) {
            cell.textContent = "0";  // Using 0 instead of O for binary theme
            cell.classList.add('o', 'filled');
          } else if (isLegal) {
            cell.classList.add('legal');
          }

          if (isLegal && !gameOver) {
            cell.addEventListener("click", handleCellClick);
          }

          smallBoard.appendChild(cell);
        }
      }

      boardContainer.appendChild(smallBoard);
    }
  }
}

async function handleCellClick(e) {
  if (gameOver) return;

  const row = parseInt(e.currentTarget.dataset.row);
  const col = parseInt(e.currentTarget.dataset.col);

  try {
    const res = await fetch(`/game/api/pvp_move/${gameId}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ row, col, player: currentPlayer }),
    });
    
    if (!res.ok) {
      const error = await res.json();
      statusDisplay.textContent = `Error: ${error.error}`;
      return;
    }
    
    const data = await res.json();
    updateUI(data);
    
    // Player switching is now handled by the backend
    
  } catch (err) {
    console.error(err);
    statusDisplay.textContent = "Connection error";
  }
}

function updateUI(data) {
  const {
    board,
    small_status,
    current_board,
    legal_moves,
    winner,
    game_over,
    current_player,
    account_owner_is_player1
  } = data;

  legalMoves = legal_moves || [];
  currentBoard = current_board;
  gameOver = game_over;
  currentPlayer = current_player; // Use backend's current player
  if (account_owner_is_player1 !== undefined) {
    accountOwnerIsPlayer1 = account_owner_is_player1;
  }
  renderBoard(board, small_status);

  if (winner === 1) {
    const winnerText = accountOwnerIsPlayer1 ? "YOU win!" : "OPPONENT wins!";
    statusDisplay.innerHTML = `<i class="fas fa-trophy"></i> PLAYER_1 wins! // ${winnerText}`;
    statusDisplay.className = accountOwnerIsPlayer1 ? "dev-game-status status-win" : "dev-game-status status-lose";
  } else if (winner === -1) {
    const winnerText = !accountOwnerIsPlayer1 ? "YOU win!" : "OPPONENT wins!";
    statusDisplay.innerHTML = `<i class="fas fa-trophy"></i> PLAYER_2 wins! // ${winnerText}`;
    statusDisplay.className = !accountOwnerIsPlayer1 ? "dev-game-status status-win" : "dev-game-status status-lose";
  } else if (game_over && winner === 0) {
    statusDisplay.innerHTML = '<i class="fas fa-equals"></i> DRAW_STATE // No winner detected';
    statusDisplay.className = "dev-game-status status-draw";
  } else if (!game_over) {
    const playerName = currentPlayer === 1 ? "PLAYER_1" : "PLAYER_2";
    const symbol = currentPlayer === 1 ? "1" : "0";
    const isYourTurn = (currentPlayer === 1 && accountOwnerIsPlayer1) || (currentPlayer === -1 && !accountOwnerIsPlayer1);
    const turnText = isYourTurn ? "Your turn" : "Opponent's turn";
    statusDisplay.innerHTML = `<i class="fas fa-terminal"></i> ${playerName} (${symbol}) // ${turnText}`;
    statusDisplay.className = "dev-game-status status-turn";
  }
}

async function resetGame() {
  gameOver = false;
  currentPlayer = 1; // Reset to player 1
  currentBoard = null;
  legalMoves = [];
  statusDisplay.textContent = "";
  statusDisplay.className = "text-center mb-6 text-lg text-white";
  
  try {
    const res = await fetch(`/game/api/pvp_reset/${gameId}`, { method: "POST" });
    if (!res.ok) throw new Error(`Reset failed: ${res.status}`);
    const data = await res.json();
    updateUI(data);
  } catch (err) {
    console.error(err);
    statusDisplay.textContent = "Error resetting game";
  }
}

// Initialize game
async function initGame() {
  try {
    const res = await fetch(`/game/api/pvp_state/${gameId}`);
    if (!res.ok) throw new Error(`Failed to load game: ${res.status}`);
    const data = await res.json();
    updateUI(data);
  } catch (err) {
    console.error(err);
    statusDisplay.textContent = "Error loading game";
  }
}

// Attach listeners after DOM is ready
document.addEventListener("DOMContentLoaded", () => {
  const resetBtn = document.getElementById("reset-btn");
  if (resetBtn) {
    resetBtn.addEventListener("click", resetGame);
  }
  initGame();
});

// Matrix Rain Animation
function createMatrixRain() {
    const container = document.getElementById('binary-background');
    if (!container) return;
    
    const chars = ['0', '1'];
    const columns = Math.floor(window.innerWidth / 20);
    const drops = [];
    
    // Initialize drops
    for (let i = 0; i < columns; i++) {
        drops[i] = Math.random() * -100;
    }
    
    function createDrop() {
        for (let i = 0; i < columns; i++) {
            if (Math.random() > 0.97) { // Much lower frequency - less crowded
                const char = document.createElement('div');
                char.className = 'binary-char';
                char.textContent = chars[Math.floor(Math.random() * chars.length)];
                char.style.left = (i * 20) + 'px';
                char.style.animationDelay = '0s'; // No delay at all
                char.style.animationDuration = (Math.random() * 3 + 5) + 's'; // Slower, more elegant
                char.style.zIndex = '-999';
                char.style.color = 'rgba(34, 197, 94, 0.4)'; // Green matrix color
                char.style.textShadow = '0 0 5px rgba(34, 197, 94, 0.3)'; // Green glow
                
                // Start some characters at random positions for immediate visibility
                const startPosition = Math.random() > 0.6 ? 
                    Math.random() * -50 + 'vh' :  // Some start closer (immediate visibility)
                    '-100vh';                      // Others start from way up (traditional)
                char.style.top = startPosition;
                
                container.appendChild(char);
                
                // Remove after animation
                setTimeout(() => {
                    if (char.parentNode) {
                        char.parentNode.removeChild(char);
                    }
                }, 8000);
            }
        }
    }
    
    // Create initial drops immediately - fewer of them
    for (let i = 0; i < 3; i++) {
        createDrop();
    }
    
    // Create drops less frequently
    setInterval(createDrop, 120);
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    createMatrixRain();
});
</script>
{% endblock %}
