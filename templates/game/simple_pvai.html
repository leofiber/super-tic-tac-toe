{% extends "base.html" %}

{% block title %}Play vs AI ({{ difficulty|title }}) - Super Tic-Tac-Toe{% endblock %}

{% block extra_head %}
<style>
/* Override matrix rain colors to green */
.binary-char {
    color: rgba(34, 197, 94, 0.4) !important;
    text-shadow: 0 0 5px rgba(34, 197, 94, 0.3) !important;
}

@keyframes binaryFall {
    0% {
        transform: translateY(0);
        opacity: 0;
        color: rgba(34, 197, 94, 0.6) !important;
        text-shadow: 0 0 8px rgba(34, 197, 94, 0.4) !important;
    }
    5% {
        opacity: 1;
        color: rgba(34, 197, 94, 0.5) !important;
        text-shadow: 0 0 6px rgba(34, 197, 94, 0.3) !important;
    }
    50% {
        opacity: 0.8;
        color: rgba(34, 197, 94, 0.4) !important;
        text-shadow: 0 0 4px rgba(34, 197, 94, 0.2) !important;
    }
    85% {
        opacity: 0.6;
        color: rgba(34, 197, 94, 0.3) !important;
        text-shadow: 0 0 2px rgba(34, 197, 94, 0.1) !important;
    }
    100% {
        transform: translateY(100vh);
        opacity: 0;
        color: rgba(34, 197, 94, 0.1) !important;
        text-shadow: none !important;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="dev-container">
    <!-- Game Header -->
    <div class="dev-game-header">
        <h1 class="dev-game-title">
            > super_tic_tac_toe --mode={{ difficulty }}_ai
        </h1>

    </div>

    <!-- Game Status -->
    <div id="status" class="dev-game-status"></div>

    <!-- Game Board Container -->
    <div class="dev-game-container">
        <div id="board" class="dev-game-board"></div>
    </div>
    
    <!-- Control Buttons -->
    <div class="dev-game-controls" style="margin-top: 2rem;">
        <button id="reset-btn" class="dev-btn" style="background: var(--dev-white); color: var(--dev-dark); border: 1px solid var(--dev-border); font-family: var(--font-mono); font-weight: 500;">
            <i class="fas fa-refresh"></i>
            New Game
        </button>
        <a href="{{ url_for('main.dashboard') }}" class="dev-btn dev-btn-ghost">
            <i class="fas fa-arrow-left"></i>
            Back to Dashboard
        </a>
    </div>
</div>

<!-- Matrix Rain Background -->
<div class="binary-bg" id="binary-background" style="z-index: -999; pointer-events: none; position: fixed;"></div>

<script>
// Game state variables
const sessionId = '{{ session_id }}';
const boardContainer = document.getElementById("board");
const statusDisplay = document.getElementById("status");
let currentBoard = null;
let gameOver = false;
let aiThinking = false;
let legalMoves = [];

function renderBoard(board, smallStatus) {
  boardContainer.innerHTML = "";

  for (let bigRow = 0; bigRow < 3; bigRow++) {
    for (let bigCol = 0; bigCol < 3; bigCol++) {
      const bigIndex = bigRow * 3 + bigCol;
      const smallBoard = document.createElement("div");
      smallBoard.className = "dev-small-board";
      smallBoard.id = `small-board-${bigIndex}`;
      
      // Check if this small board is won
      const smallWinner = smallStatus[bigRow][bigCol];
      if (smallWinner === 1) {
        console.log(`ðŸ”µ PLAYER captured board [${bigRow}][${bigCol}]!`);
        smallBoard.classList.add('won-x');
      } else if (smallWinner === -1 || smallWinner === 2) {
        console.log(`ðŸ”´ AI captured board [${bigRow}][${bigCol}]!`);
        smallBoard.classList.add('won-o');
      }
      
      // Highlight current board
      if (currentBoard && currentBoard[0] === bigRow && currentBoard[1] === bigCol) {
        smallBoard.classList.add('active');
      }

      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          const r = bigRow * 3 + i;
          const c = bigCol * 3 + j;
          const val = board[r][c];
          const cell = document.createElement("div");
          const isLegal = legalMoves.some(([lr, lc]) => lr === r && lc === c);

          cell.className = "dev-cell";
          cell.dataset.row = r;
          cell.dataset.col = c;
          
          if (val === 1) {
            cell.textContent = "1";  // Using 1 instead of X for binary theme
            cell.classList.add('x', 'filled');
          } else if (val === -1) {
            cell.textContent = "0";  // Using 0 instead of O for binary theme
            cell.classList.add('o', 'filled');
          } else if (isLegal) {
            cell.classList.add('legal');
          }

          if (isLegal && !gameOver && !aiThinking) {
            cell.addEventListener("click", handleCellClick);
          }

          smallBoard.appendChild(cell);
        }
      }

      boardContainer.appendChild(smallBoard);
    }
  }
}

async function handleCellClick(e) {
  if (gameOver || aiThinking) return;

  const row = parseInt(e.currentTarget.dataset.row);
  const col = parseInt(e.currentTarget.dataset.col);

  try {
    const res = await fetch(`/game/api/move/${sessionId}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ row, col }),
    });
    if (!res.ok) {
      const error = await res.json();
      statusDisplay.textContent = `Error: ${error.error}`;
      return;
    }
    const data = await res.json();
    updateUI(data);

    if (!data.winner && !data.game_over) {
      aiThinking = true;
      statusDisplay.innerHTML = '<i class="fas fa-cog fa-spin"></i> AI_PROCESS running... // Computing optimal move';
      statusDisplay.className = "dev-game-status status-thinking";
      
      // Reasonable delay for AI thinking
      setTimeout(async () => {
        const aiRes = await fetch(`/game/api/ai_move/${sessionId}`, { method: "POST" });
        if (!aiRes.ok) {
          const error = await aiRes.json();
          statusDisplay.textContent = `AI Error: ${error.error}`;
          aiThinking = false;
          return;
        }
        const aiData = await aiRes.json();
        aiThinking = false;
        updateUI(aiData);
      }, 1200); // Give AI more realistic thinking time
    }
  } catch (err) {
    console.error(err);
    statusDisplay.textContent = "Connection error";
  }
}

function updateUI(data) {
  const {
    board,
    small_status,
    current_board,
    legal_moves,
    winner,
    game_over
  } = data;

  legalMoves = legal_moves || [];
  currentBoard = current_board;
  gameOver = game_over;
  renderBoard(board, small_status);

  if (winner === 1) {
    statusDisplay.innerHTML = '<i class="fas fa-check"></i> PLAYER_1 wins! // You defeated the AI';
    statusDisplay.className = "dev-game-status status-win";
  } else if (winner === -1) {
    statusDisplay.innerHTML = '<i class="fas fa-times"></i> AI_PROCESS wins! // Better luck next time';
    statusDisplay.className = "dev-game-status status-lose";
  } else if (game_over && winner === 0) {
    // Only show draw if game is actually over AND winner is 0
    statusDisplay.innerHTML = '<i class="fas fa-equals"></i> DRAW_STATE // No winner detected';
    statusDisplay.className = "dev-game-status status-draw";
  } else if (!aiThinking && !game_over) {
    statusDisplay.innerHTML = '<i class="fas fa-terminal"></i> AWAITING_INPUT // Your move';
    statusDisplay.className = "dev-game-status status-turn";
  }
}

async function resetGame() {
  console.log("resetGame() called");
  gameOver = false;
  aiThinking = false;
  currentBoard = null;
  legalMoves = [];
  statusDisplay.textContent = "";
  statusDisplay.className = "text-center mb-6 text-lg text-white";
  
  try {
    const res = await fetch(`/game/api/reset/${sessionId}`, { method: "POST" });
    if (!res.ok) throw new Error(`Reset failed: ${res.status}`);
    const data = await res.json();
    updateUI(data);
    
    // Check if AI should go first after reset
    const playerStartsFirst = data.player_starts_first !== undefined ? data.player_starts_first : true;
    if (!playerStartsFirst && !data.game_over) {
      console.log("AI goes first after reset! player_starts_first =", playerStartsFirst);
      aiThinking = true;
      statusDisplay.innerHTML = '<i class="fas fa-cog fa-spin"></i> AI_PROCESS initializing... // Computing first move';
      statusDisplay.className = "dev-game-status status-thinking";
      
      setTimeout(async () => {
        const aiRes = await fetch(`/game/api/ai_move/${sessionId}`, { method: "POST" });
        if (!aiRes.ok) {
          const error = await aiRes.json();
          statusDisplay.textContent = `AI Error: ${error.error}`;
          aiThinking = false;
          return;
        }
        const aiData = await aiRes.json();
        aiThinking = false;
        updateUI(aiData);
      }, 1200);
    }
  } catch (err) {
    console.error(err);
    statusDisplay.textContent = "Error resetting game";
  }
}

// Initialize game
async function initGame() {
  try {
    const res = await fetch(`/game/api/state/${sessionId}`);
    if (!res.ok) throw new Error(`Failed to load game: ${res.status}`);
    const data = await res.json();
    updateUI(data);
    
    // Check if AI should go first (AI starts when player_starts_first is false)
    const playerStartsFirst = data.player_starts_first !== undefined ? data.player_starts_first : true;
    if (!playerStartsFirst && !data.game_over) {
      console.log("AI goes first! player_starts_first =", playerStartsFirst);
      aiThinking = true;
      statusDisplay.innerHTML = '<i class="fas fa-cog fa-spin"></i> AI_PROCESS initializing... // Computing first move';
      statusDisplay.className = "dev-game-status status-thinking";
      
      setTimeout(async () => {
        const aiRes = await fetch(`/game/api/ai_move/${sessionId}`, { method: "POST" });
        if (!aiRes.ok) {
          const error = await aiRes.json();
          statusDisplay.textContent = `AI Error: ${error.error}`;
          aiThinking = false;
          return;
        }
        const aiData = await aiRes.json();
        aiThinking = false;
        updateUI(aiData);
      }, 1200);
    }
  } catch (err) {
    console.error(err);
    statusDisplay.textContent = "Error loading game";
  }
}

// Attach listeners after DOM is ready
console.log("game.js loaded");
document.addEventListener("DOMContentLoaded", () => {
  const resetBtn = document.getElementById("reset-btn");
  console.log("DOMContentLoaded: reset-btn =", resetBtn);
  if (resetBtn) {
    resetBtn.addEventListener("click", () => {
      console.log("reset-btn clicked");
      resetGame();
    });
  }
  initGame(); // Load game state instead of resetting
});

// Matrix Rain Animation
function createMatrixRain() {
    const container = document.getElementById('binary-background');
    if (!container) return;
    
    const chars = ['0', '1'];
    const columns = Math.floor(window.innerWidth / 20);
    const drops = [];
    
    // Initialize drops
    for (let i = 0; i < columns; i++) {
        drops[i] = Math.random() * -100;
    }
    
    function createDrop() {
        for (let i = 0; i < columns; i++) {
            if (Math.random() > 0.97) { // Much lower frequency - less crowded
                const char = document.createElement('div');
                char.className = 'binary-char';
                char.textContent = chars[Math.floor(Math.random() * chars.length)];
                char.style.left = (i * 20) + 'px';
                char.style.animationDelay = '0s'; // No delay at all
                char.style.animationDuration = (Math.random() * 3 + 5) + 's'; // Slower, more elegant
                char.style.zIndex = '-999';
                char.style.color = 'rgba(34, 197, 94, 0.4)'; // Green matrix color
                char.style.textShadow = '0 0 5px rgba(34, 197, 94, 0.3)'; // Green glow
                
                // Start some characters at random positions for immediate visibility
                const startPosition = Math.random() > 0.6 ? 
                    Math.random() * -50 + 'vh' :  // Some start closer (immediate visibility)
                    '-100vh';                      // Others start from way up (traditional)
                char.style.top = startPosition;
                
                container.appendChild(char);
                
                // Remove after animation
                setTimeout(() => {
                    if (char.parentNode) {
                        char.parentNode.removeChild(char);
                    }
                }, 8000);
            }
        }
    }
    
    // Create initial drops immediately - fewer of them
    for (let i = 0; i < 3; i++) {
        createDrop();
    }
    
    // Create drops less frequently
    setInterval(createDrop, 120);
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    createMatrixRain();
});
</script>
{% endblock %}
